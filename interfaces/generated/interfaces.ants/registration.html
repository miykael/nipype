
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Neuroimaging in Python - Pipelines and Interfaces &#8212; nipy pipeline and interfaces package</title>
    <link rel="stylesheet" href="../../../_static/nipype.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="../../../about.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
 
<meta name="keywords" content="nipype, neuroimaging, pipeline, workflow, parallel, python, neuroscience">
<script type="text/javascript">
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-339450-7', 'nipy.org/nipype');
  ga('send', 'pageview');
</script>
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'nipy/nipype'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

  </head><body>
<div class="header-wrapper">
    <div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
            <a href="../../../index.html">
            <img src="../../../_static/nipype-banner-bg.png" alt="NIPY logo"  border="0" />
        <div style="margin-top: 1em;
                border-top: 1px solid #AAA;
                border-bottom: 1px solid #AAA;
                border-radius: 5px;
                padding: 3px 1em;">
            <link rel="stylesheet" href="http://www.google.com/cse/style/look/default.css" type="text/css" />
<style type="text/css">
    a.navbar {
    color: ;
    letter-spacing: .05em;
    font-weight: bold;
        }
</style>

<a class="navbar" href="../../../index.html">Home</a> ·
<a class="navbar" href="../../../quickstart.html">Quickstart</a> ·
<a class="navbar" href="../../../documentation.html">Documentation</a> ·
<a class="navbar" href="../../../about.html">About</a> ·
<a class="navbar" href="http://nipy.org">Nipy</a>

        </div>
    </div>
</div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<style type="text/css">
    input.gsc-input {
        border-color: #BCCDF0;
    }
    input.gsc-search-button {
        border-color: #666666;
        background-color: #CECECE;
        padding: 0;
    }
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
    div.sphinxsidebar input[type="text"] {
        width: 100%;
    }
    div.sphinxsidebar input[type="submit"] {
        width: 100%;
    }
</style>

<div class="sidebarblock">
    <script>
      (function() {
        var cx = '010960497803984932957:u8pmqf7fdoq';
        var gcse = document.createElement('script');
        gcse.type = 'text/javascript';
        gcse.async = true;
        gcse.src = 'https://cse.google.com/cse.js?cx=' + cx;
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(gcse, s);
      })();
    </script>
    <gcse:search></gcse:search>
</div>

  <h3><a href="../../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">interfaces.ants.registration</a><ul>
<li><a class="reference internal" href="#measureimagesimilarity">MeasureImageSimilarity</a><ul>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#registration">Registration</a><ul>
<li><a class="reference internal" href="#id1">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#registrationsynquick">RegistrationSynQuick</a><ul>
<li><a class="reference internal" href="#id2">Examples</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<style type="text/css">
    div.sphinxsidebar .tile {
        border: 1px solid #D1DDE2;
        border-radius: 10px;
        background-color: #E1E8EC;
        padding-left: 0.5em;
        margin: 1em 0;
    }
</style>
<div class="sidebarblock">
    <h3>Versions</h3>

    <div class="tile">
        <table style="width: 100%;">
            <tr style="font-weight: bold;">
                <td align="left">Release</td><td align="right">Devel</td>
            </tr>
            <tr>
                <td align="left">1.1.3</td><td align="right">1.1.4-dev+g93c475b</td>
            </tr>
            <tr>
                <td align="left"><a href="../../../users/install.html">Download</a></td>
                <td align="right"><a href="https://github.com/nipy/nipype">Github</a></td>
            </tr>
        </table>
    </div>
</div>


<script type="text/javascript">
    (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
</script>

<h3>Links</h3>

<ul>
    <li>Docs: <a href="http://nipy.org/nipype">Stable</a> · <a href="http://nipype.readthedocs.org/en/latest/">Dev</a></li>
    <li>Code: <a href="http://github.com/nipy/nipype">Github</a> · <a href="http://github.com/nipy/nipype/issues">Bugs-Requests</a></li>
    <li>Forum: <a href="https://neurostars.org/search?q=nipype">User</a> · <a href="https://mail.python.org/mailman/listinfo/neuroimaging">Developer</a></li>
    <li>Chat: <a href="https://gitter.im/nipy/nipype">Gitter</a> · <a href="https://brainhack.slack.com/messages/C1FR76RAL">Slack</a></li>
    <li><a href="about.html#funding">Funding</a> · <a href="http://nipy.org/software/license/index.html"><img src="https://img.shields.io/pypi/l/nipype.svg" alt="License"></a></li>
    <li><a href="https://travis-ci.org/nipy/nipype"><img src="https://travis-ci.org/nipy/nipype.png?branch=master" alt="travis"></a> · <a href='https://codecov.io/gh/nipy/nipype'><img src='https://codecov.io/gh/nipy/nipype/branch/master/graph/badge.svg' alt='Coverage Status' /></a></li>
    <a href='https://pypi.python.org/pypi/nipype/'><img src='https://img.shields.io/pypi/pyversions/nipype.svg' alt='Python Versions' /></a></li>
</ul>

 
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="interfaces-ants-registration">
<h1>interfaces.ants.registration<a class="headerlink" href="#interfaces-ants-registration" title="Permalink to this headline">¶</a></h1>
<span class="target" id="nipype-interfaces-ants-registration-measureimagesimilarity"></span><div class="section" id="measureimagesimilarity">
<span id="index-0"></span><h2>MeasureImageSimilarity<a class="headerlink" href="#measureimagesimilarity" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://github.com/nipy/nipype/tree/93c475b/nipype/interfaces/ants/registration.py#L1428">Link to code</a></p>
<p>Wraps command <strong>MeasureImageSimilarity</strong></p>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.interfaces.ants</span> <span class="k">import</span> <span class="n">MeasureImageSimilarity</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span> <span class="o">=</span> <span class="n">MeasureImageSimilarity</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="s1">&#39;MI&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image</span> <span class="o">=</span> <span class="s1">&#39;T1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image</span> <span class="o">=</span> <span class="s1">&#39;resting.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metric_weight</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">radius_or_number_of_bins</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sampling_strategy</span> <span class="o">=</span> <span class="s1">&#39;Regular&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sampling_percentage</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image_mask</span> <span class="o">=</span> <span class="s1">&#39;mask.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image_mask</span> <span class="o">=</span> <span class="s1">&#39;mask.nii.gz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sim</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;MeasureImageSimilarity --dimensionality 3 --masks [&quot;mask.nii&quot;,&quot;mask.nii.gz&quot;] --metric MI[&quot;T1.nii&quot;,&quot;resting.nii&quot;,1.0,5,Regular,1.0]&#39;</span>
</pre></div>
</div>
<p>Inputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[Mandatory]
fixed_image: (an existing file name)
        Image to which the moving image is warped
metric: (&#39;CC&#39; or &#39;MI&#39; or &#39;Mattes&#39; or &#39;MeanSquares&#39; or &#39;Demons&#39; or
         &#39;GC&#39;)
        flag: %s
moving_image: (an existing file name)
        Image to apply transformation to (generally a coregistered
        functional)
radius_or_number_of_bins: (an integer (int or long))
        The number of bins in each stage for the MI and Mattes metric, or
        the radius for other metrics
        requires: metric
sampling_percentage: (0.0 &lt;= a floating point number &lt;= 1.0)
        Percentage of points accessible to the sampling strategy over which
        to optimize the metric.
        requires: metric

[Optional]
args: (a unicode string)
        Additional parameters to the command
        flag: %s
dimension: (2 or 3 or 4)
        Dimensionality of the fixed/moving image pair
        flag: --dimensionality %d, position: 1
environ: (a dictionary with keys which are a bytes or None or a value
         of class &#39;str&#39; and with values which are a bytes or None or a value
         of class &#39;str&#39;, nipype default value: {})
        Environment variables
fixed_image_mask: (an existing file name)
        mask used to limit metric sampling region of the fixed image
        flag: %s
metric_weight: (a float, nipype default value: 1.0)
        The &quot;metricWeight&quot; variable is not used.
        requires: metric
moving_image_mask: (an existing file name)
        mask used to limit metric sampling region of the moving image
        requires: fixed_image_mask
num_threads: (an integer (int or long), nipype default value: 1)
        Number of ITK threads to use
sampling_strategy: (&#39;None&#39; or &#39;Regular&#39; or &#39;Random&#39;, nipype default
         value: None)
        Manner of choosing point set over which to optimize the metric.
        Defaults to &quot;None&quot; (i.e. a dense sampling of one sample per voxel).
        requires: metric
</pre></div>
</div>
<p>Outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">similarity</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">float</span><span class="p">)</span>
</pre></div>
</div>
<span class="target" id="nipype-interfaces-ants-registration-registration"></span></div>
</div>
<div class="section" id="registration">
<span id="index-1"></span><h2>Registration<a class="headerlink" href="#registration" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://github.com/nipy/nipype/tree/93c475b/nipype/interfaces/ants/registration.py#L558">Link to code</a></p>
<p>Wraps command <strong>antsRegistration</strong></p>
<p>ANTs Registration command for registration of images</p>
<p><a class="reference external" href="http://stnava.github.io/ANTs/">antsRegistration</a> registers a <code class="docutils literal notranslate"><span class="pre">moving_image</span></code> to a <code class="docutils literal notranslate"><span class="pre">fixed_image</span></code>,
using a predefined (sequence of) cost function(s) and transformation operations.
The cost function is defined using one or more ‘metrics’, specifically
local cross-correlation (<code class="docutils literal notranslate"><span class="pre">CC</span></code>), Mean Squares (<code class="docutils literal notranslate"><span class="pre">MeanSquares</span></code>), Demons (<code class="docutils literal notranslate"><span class="pre">Demons</span></code>),
global correlation (<code class="docutils literal notranslate"><span class="pre">GC</span></code>), or Mutual Information (<code class="docutils literal notranslate"><span class="pre">Mattes</span></code> or <code class="docutils literal notranslate"><span class="pre">MI</span></code>).</p>
<p>ANTS can use both linear (<code class="docutils literal notranslate"><span class="pre">Translation</span></code>, <code class="docutils literal notranslate"><span class="pre">Rigid</span></code>, <code class="docutils literal notranslate"><span class="pre">Affine</span></code>, <code class="docutils literal notranslate"><span class="pre">CompositeAffine</span></code>,
or <code class="docutils literal notranslate"><span class="pre">Translation</span></code>) and non-linear transformations (<code class="docutils literal notranslate"><span class="pre">BSpline</span></code>, <code class="docutils literal notranslate"><span class="pre">GaussianDisplacementField</span></code>,
<code class="docutils literal notranslate"><span class="pre">TimeVaryingVelocityField</span></code>, <code class="docutils literal notranslate"><span class="pre">TimeVaryingBSplineVelocityField</span></code>, <code class="docutils literal notranslate"><span class="pre">SyN</span></code>, <code class="docutils literal notranslate"><span class="pre">BSplineSyN</span></code>,
<code class="docutils literal notranslate"><span class="pre">Exponential</span></code>, or <code class="docutils literal notranslate"><span class="pre">BSplineExponential</span></code>). Usually, registration is done in multiple
<em>stages</em>. For example first an Affine, then a Rigid, and ultimately a non-linear
(Syn)-transformation.</p>
<p>antsRegistration can be initialized using one ore more transforms from moving_image
to fixed_image with the <code class="docutils literal notranslate"><span class="pre">initial_moving_transform</span></code>-input. For example, when you
already have a warpfield that corrects for geometrical distortions in an EPI (functional) image,
that you want to apply before an Affine registration to a structural image.
You could put this transform into ‘intial_moving_transform’.</p>
<p>The Registration-interface can output the resulting transform(s) that map moving_image to
fixed_image in a single file as a <code class="docutils literal notranslate"><span class="pre">composite_transform</span></code> (if <code class="docutils literal notranslate"><span class="pre">write_composite_transform</span></code>
is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>), or a list of transforms as <code class="docutils literal notranslate"><span class="pre">forwards_transforms</span></code>. It can also output
inverse transforms (from <code class="docutils literal notranslate"><span class="pre">fixed_image</span></code> to <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>) in a similar fashion using
<code class="docutils literal notranslate"><span class="pre">inverse_composite_transform</span></code>. Note that the order of <code class="docutils literal notranslate"><span class="pre">forward_transforms</span></code> is in ‘natural’
order: the first element should be applied first, the last element should be applied last.</p>
<p>Note, however, that ANTS tools always apply lists of transformations in reverse order (the last
transformation in the list is applied first). Therefore, if the output forward_transforms
is a list, one can not directly feed it into, for example, <code class="docutils literal notranslate"><span class="pre">ants.ApplyTransforms</span></code>. To
make <code class="docutils literal notranslate"><span class="pre">ants.ApplyTransforms</span></code> apply the transformations in the same order as <code class="docutils literal notranslate"><span class="pre">ants.Registration</span></code>,
you have to provide the list of transformations in reverse order from <code class="docutils literal notranslate"><span class="pre">forward_transforms</span></code>.
<code class="docutils literal notranslate"><span class="pre">reverse_forward_transforms</span></code> outputs <code class="docutils literal notranslate"><span class="pre">forward_transforms</span></code> in reverse order and can be used for
this purpose. Note also that, because <code class="docutils literal notranslate"><span class="pre">composite_transform</span></code> is always a single file, this
output is preferred for  most use-cases.</p>
<p>More information can be found in the <a class="reference external" href="https://sourceforge.net/projects/advants/files/Documentation/ants.pdf/download">ANTS
manual</a>.</p>
<p>See below for some useful examples.</p>
<div class="section" id="id1">
<h3>Examples<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Set up a Registration node with some default settings. This Node registers
‘fixed1.nii’ to ‘moving1.nii’ by first fitting a linear ‘Affine’ transformation, and
then a non-linear ‘SyN’ transformation, both using the Mutual Information-cost
metric.</p>
<p>The registration is initialized by first applying the (linear) transform
trans.mat.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">copy</span><span class="o">,</span> <span class="nn">pprint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.interfaces.ants</span> <span class="k">import</span> <span class="n">Registration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="n">Registration</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image</span> <span class="o">=</span> <span class="s1">&#39;fixed1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image</span> <span class="o">=</span> <span class="s1">&#39;moving1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">output_transform_prefix</span> <span class="o">=</span> <span class="s2">&quot;output_&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">initial_moving_transform</span> <span class="o">=</span> <span class="s1">&#39;trans.mat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Affine&#39;</span><span class="p">,</span> <span class="s1">&#39;SyN&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">transform_parameters</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">2.0</span><span class="p">,),</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">number_of_iterations</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1500</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">write_composite_transform</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">collapse_output_transforms</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">initialize_transforms_per_stage</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mattes&#39;</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metric_weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="c1"># Default (value ignored currently by ANTs)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">radius_or_number_of_bins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sampling_strategy</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Random&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sampling_percentage</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">convergence_threshold</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.e-8</span><span class="p">,</span> <span class="mf">1.e-9</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">convergence_window_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">smoothing_sigmas</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sigma_units</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vox&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">shrink_factors</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">use_estimate_learning_rate_once</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">use_histogram_matching</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span> <span class="c1"># This is the default</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">output_warped_image</span> <span class="o">=</span> <span class="s1">&#39;output_warped_image.nii.gz&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 0 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># doctest: +SKIP</span>
</pre></div>
</div>
<p>Same as reg1, but first invert the initial transform (‘trans.mat’) before applying it.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">invert_initial_moving_transform</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg1</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg1</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">winsorize_lower_quantile</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg1</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.025, 1.0 ]  --write-composite-transform 1&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg1</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># doctest: +SKIP</span>
</pre></div>
</div>
<p>Clip extremely high intensity data points using winsorize_upper_quantile. All data points
higher than the 0.975 quantile are set to the value of the 0.975 quantile.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg2</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">winsorize_upper_quantile</span> <span class="o">=</span> <span class="mf">0.975</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg2</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 0.975 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Clip extremely low intensity data points using winsorize_lower_quantile. All data points
lower than the 0.025 quantile are set to the original value at the 0.025 quantile.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg3</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">winsorize_lower_quantile</span> <span class="o">=</span> <span class="mf">0.025</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">winsorize_upper_quantile</span> <span class="o">=</span> <span class="mf">0.975</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.025, 0.975 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Use float instead of double for computations (saves memory usage)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg3a</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3a</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">float</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3a</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --float 1 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Force to use double instead of float for computations (more precision and memory usage).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reg3b</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3b</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">float</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg3b</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --float 0 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>‘collapse_output_transforms’ can be used to put all transformation in a single ‘composite_transform’-
file. Note that forward_transforms will now be an empty list.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test collapse transforms flag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">save_state</span> <span class="o">=</span> <span class="s1">&#39;trans.mat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">restore_state</span> <span class="o">=</span> <span class="s1">&#39;trans.mat&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">initialize_transforms_per_stage</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">collapse_output_transforms</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outputs</span> <span class="o">=</span> <span class="n">reg4</span><span class="o">.</span><span class="n">_list_outputs</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>  <span class="c1"># doctest: +ELLIPSIS,</span>
<span class="go">{&#39;composite_transform&#39;: &#39;.../nipype/testing/data/output_Composite.h5&#39;,</span>
<span class="go"> &#39;elapsed_time&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;forward_invert_flags&#39;: [],</span>
<span class="go"> &#39;forward_transforms&#39;: [],</span>
<span class="go"> &#39;inverse_composite_transform&#39;: &#39;.../nipype/testing/data/output_InverseComposite.h5&#39;,</span>
<span class="go"> &#39;inverse_warped_image&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;metric_value&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;reverse_invert_flags&#39;: [],</span>
<span class="go"> &#39;reverse_transforms&#39;: [],</span>
<span class="go"> &#39;save_state&#39;: &#39;.../nipype/testing/data/trans.mat&#39;,</span>
<span class="go"> &#39;warped_image&#39;: &#39;.../nipype/testing/data/output_warped_image.nii.gz&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 1 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 1 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --restore-state trans.mat --save-state trans.mat --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test collapse transforms flag</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4b</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4b</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">write_composite_transform</span> <span class="o">=</span> <span class="kc">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">outputs</span> <span class="o">=</span> <span class="n">reg4b</span><span class="o">.</span><span class="n">_list_outputs</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>  <span class="c1"># doctest: +ELLIPSIS,</span>
<span class="go">{&#39;composite_transform&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;elapsed_time&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;forward_invert_flags&#39;: [False, False],</span>
<span class="go"> &#39;forward_transforms&#39;: [&#39;.../nipype/testing/data/output_0GenericAffine.mat&#39;,</span>
<span class="go"> &#39;.../nipype/testing/data/output_1Warp.nii.gz&#39;],</span>
<span class="go"> &#39;inverse_composite_transform&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;inverse_warped_image&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;metric_value&#39;: &lt;undefined&gt;,</span>
<span class="go"> &#39;reverse_invert_flags&#39;: [True, False],</span>
<span class="go"> &#39;reverse_transforms&#39;: [&#39;.../nipype/testing/data/output_0GenericAffine.mat&#39;,     &#39;.../nipype/testing/data/output_1InverseWarp.nii.gz&#39;],</span>
<span class="go"> &#39;save_state&#39;: &#39;.../nipype/testing/data/trans.mat&#39;,</span>
<span class="go"> &#39;warped_image&#39;: &#39;.../nipype/testing/data/output_warped_image.nii.gz&#39;}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4b</span><span class="o">.</span><span class="n">aggregate_outputs</span><span class="p">()</span>  <span class="c1"># doctest: +SKIP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg4b</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 1 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 1 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --restore-state trans.mat --save-state trans.mat --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 0&#39;</span>
</pre></div>
</div>
<p>One can use multiple similarity metrics in a single registration stage.The Node below first
performs a linear registation using only the Mutual Information (‘Mattes’)-metric.
In a second stage, it performs a non-linear registration (‘Syn’) using both a
Mutual Information and a local cross-correlation (‘CC’)-metric. Both metrics are weighted
equally (‘metric_weight’ is .5 for both). The Mutual Information- metric uses 32 bins.
The local cross-correlations (correlations between every voxel’s neighborhoods) is computed
with a radius of 4.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test multiple metrics per stage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image</span> <span class="o">=</span> <span class="s1">&#39;fixed1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image</span> <span class="o">=</span> <span class="s1">&#39;moving1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mattes&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;Mattes&#39;</span><span class="p">,</span> <span class="s1">&#39;CC&#39;</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">metric_weight</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span><span class="o">.</span><span class="mi">5</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">radius_or_number_of_bins</span> <span class="o">=</span> <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="p">[</span><span class="mi">32</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sampling_strategy</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Random&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="c1"># use default strategy in second stage</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">sampling_percentage</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg5</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 0.5, 32, None, 0.05 ] --metric CC[ fixed1.nii, moving1.nii, 0.5, 4, None, 0.1 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>ANTS Registration can also use multiple modalities to perform the registration. Here it is assumed
that fixed1.nii and fixed2.nii are in the same space, and so are moving1.nii and
moving2.nii. First, a linear registration is performed matching fixed1.nii to moving1.nii,
then a non-linear registration is performed to match fixed2.nii to moving2.nii, starting from
the transformation of the first step.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test multiple inputS</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg6</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg6</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fixed1.nii&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed2.nii&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg6</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;moving1.nii&#39;</span><span class="p">,</span> <span class="s1">&#39;moving2.nii&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg6</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 0.5, 32, None, 0.05 ] --metric CC[ fixed2.nii, moving2.nii, 0.5, 4, None, 0.1 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Different methods can be used for the interpolation when applying transformations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test Interpolation Parameters (BSpline)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7a</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7a</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="s1">&#39;BSpline&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7a</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">interpolation_parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7a</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation BSpline[ 3 ] --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test Interpolation Parameters (MultiLabel/Gaussian)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7b</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7b</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">interpolation</span> <span class="o">=</span> <span class="s1">&#39;Gaussian&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7b</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">interpolation_parameters</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg7b</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Gaussian[ 1.0, 1.0 ] --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>BSplineSyN non-linear registration with custom parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test Extended Transform Parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg8</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg8</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">transforms</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Affine&#39;</span><span class="p">,</span> <span class="s1">&#39;BSplineSyN&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg8</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">transform_parameters</span> <span class="o">=</span> <span class="p">[(</span><span class="mf">2.0</span><span class="p">,),</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg8</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform BSplineSyN[ 0.25, 26, 0, 3 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Mask the fixed image in the second stage of the registration (but not the first).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test masking</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg9</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg9</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image_masks</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NULL&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed1.nii&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg9</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ trans.mat, 1 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --masks [ NULL, NULL ] --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --masks [ fixed1.nii, NULL ] --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Here we use both a warpfield and a linear transformation, before registration commences.  Note that
the first transformation that needs to be applied (‘ants_Warp.nii.gz’) is last in the list of
‘initial_moving_transform’.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Test initialization with multiple transforms matrices (e.g., unwarp and affine transform)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg10</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">reg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg10</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">initial_moving_transform</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;func_to_struct.mat&#39;</span><span class="p">,</span> <span class="s1">&#39;ants_Warp.nii.gz&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg10</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">invert_initial_moving_transform</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg10</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistration --collapse-output-transforms 0 --dimensionality 3 --initial-moving-transform [ func_to_struct.mat, 0 ] [ ants_Warp.nii.gz, 0 ] --initialize-transforms-per-stage 0 --interpolation Linear --output [ output_, output_warped_image.nii.gz ] --transform Affine[ 2.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32, Random, 0.05 ] --convergence [ 1500x200, 1e-08, 20 ] --smoothing-sigmas 1.0x0.0vox --shrink-factors 2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --transform SyN[ 0.25, 3.0, 0.0 ] --metric Mattes[ fixed1.nii, moving1.nii, 1, 32 ] --convergence [ 100x50x30, 1e-09, 20 ] --smoothing-sigmas 2.0x1.0x0.0vox --shrink-factors 3x2x1 --use-estimate-learning-rate-once 1 --use-histogram-matching 1 --winsorize-image-intensities [ 0.0, 1.0 ]  --write-composite-transform 1&#39;</span>
</pre></div>
</div>
<p>Inputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[Mandatory]
fixed_image: (a list of items which are an existing file name)
        Image to which the moving_image should be transformed(usually a
        structural image)
metric: (a list of items which are &#39;CC&#39; or &#39;MeanSquares&#39; or &#39;Demons&#39;
         or &#39;GC&#39; or &#39;MI&#39; or &#39;Mattes&#39; or a list of items which are &#39;CC&#39; or
         &#39;MeanSquares&#39; or &#39;Demons&#39; or &#39;GC&#39; or &#39;MI&#39; or &#39;Mattes&#39;)
        the metric(s) to use for each stage. Note that multiple metrics per
        stage are not supported in ANTS 1.9.1 and earlier.
metric_weight: (a list of items which are a float or a list of items
         which are a float, nipype default value: [1.0])
        the metric weight(s) for each stage. The weights must sum to 1 per
        stage.
        requires: metric
moving_image: (a list of items which are an existing file name)
        Image that will be registered to the space of fixed_image. This is
        theimage on which the transformations will be applied to
shrink_factors: (a list of items which are a list of items which are
         an integer (int or long))
smoothing_sigmas: (a list of items which are a list of items which
         are a float)
transforms: (a list of items which are &#39;Rigid&#39; or &#39;Affine&#39; or
         &#39;CompositeAffine&#39; or &#39;Similarity&#39; or &#39;Translation&#39; or &#39;BSpline&#39; or
         &#39;GaussianDisplacementField&#39; or &#39;TimeVaryingVelocityField&#39; or
         &#39;TimeVaryingBSplineVelocityField&#39; or &#39;SyN&#39; or &#39;BSplineSyN&#39; or
         &#39;Exponential&#39; or &#39;BSplineExponential&#39;)
        flag: %s

[Optional]
args: (a unicode string)
        Additional parameters to the command
        flag: %s
collapse_output_transforms: (a boolean, nipype default value: True)
        Collapse output transforms. Specifically, enabling this option
        combines all adjacent linear transforms and composes all adjacent
        displacement field transforms before writing the results to disk.
        flag: --collapse-output-transforms %d
convergence_threshold: (a list of at least 1 items which are a float,
         nipype default value: [1e-06])
        requires: number_of_iterations
convergence_window_size: (a list of at least 1 items which are an
         integer (int or long), nipype default value: [10])
        requires: convergence_threshold
dimension: (3 or 2, nipype default value: 3)
        image dimension (2 or 3)
        flag: --dimensionality %d
environ: (a dictionary with keys which are a bytes or None or a value
         of class &#39;str&#39; and with values which are a bytes or None or a value
         of class &#39;str&#39;, nipype default value: {})
        Environment variables
fixed_image_mask: (an existing file name)
        Mask used to limit metric sampling region of the fixed imagein all
        stages
        flag: %s
        mutually_exclusive: fixed_image_masks
fixed_image_masks: (a list of items which are an existing file name
         or &#39;NULL&#39;)
        Masks used to limit metric sampling region of the fixed image,
        defined per registration stage(Use &quot;NULL&quot; to omit a mask at a given
        stage)
        mutually_exclusive: fixed_image_mask
float: (a boolean)
        Use float instead of double for computations.
        flag: --float %d
initial_moving_transform: (a list of items which are an existing file
         name)
        A transform or a list of transforms that should be appliedbefore the
        registration begins. Note that, when a list is given,the
        transformations are applied in reverse order.
        flag: %s
        mutually_exclusive: initial_moving_transform_com
initial_moving_transform_com: (0 or 1 or 2)
        Align the moving_image nad fixed_image befor registration usingthe
        geometric center of the images (=0), the image intensities (=1),or
        the origin of the images (=2)
        flag: %s
        mutually_exclusive: initial_moving_transform
initialize_transforms_per_stage: (a boolean, nipype default value:
         False)
        Initialize linear transforms from the previous stage. By enabling
        this option, the current linear stage transform is directly
        intialized from the previous stages linear transform; this allows
        multiple linear stages to be run where each stage directly updates
        the estimated linear transform from the previous stage. (e.g.
        Translation -&gt; Rigid -&gt; Affine).
        flag: --initialize-transforms-per-stage %d
interpolation: (&#39;Linear&#39; or &#39;NearestNeighbor&#39; or &#39;CosineWindowedSinc&#39;
         or &#39;WelchWindowedSinc&#39; or &#39;HammingWindowedSinc&#39; or
         &#39;LanczosWindowedSinc&#39; or &#39;BSpline&#39; or &#39;MultiLabel&#39; or &#39;Gaussian&#39;,
         nipype default value: Linear)
        flag: %s
interpolation_parameters: (a tuple of the form: (an integer (int or
         long)) or a tuple of the form: (a float, a float))
invert_initial_moving_transform: (a list of items which are a
         boolean)
        One boolean or a list of booleans that indicatewhether the
        inverse(s) of the transform(s) definedin initial_moving_transform
        should be used.
        mutually_exclusive: initial_moving_transform_com
        requires: initial_moving_transform
metric_item_trait: (&#39;CC&#39; or &#39;MeanSquares&#39; or &#39;Demons&#39; or &#39;GC&#39; or &#39;MI&#39;
         or &#39;Mattes&#39;)
metric_stage_trait: (&#39;CC&#39; or &#39;MeanSquares&#39; or &#39;Demons&#39; or &#39;GC&#39; or
         &#39;MI&#39; or &#39;Mattes&#39; or a list of items which are &#39;CC&#39; or &#39;MeanSquares&#39;
         or &#39;Demons&#39; or &#39;GC&#39; or &#39;MI&#39; or &#39;Mattes&#39;)
metric_weight_item_trait: (a float, nipype default value: 1.0)
metric_weight_stage_trait: (a float or a list of items which are a
         float)
moving_image_mask: (an existing file name)
        mask used to limit metric sampling region of the moving imagein all
        stages
        mutually_exclusive: moving_image_masks
        requires: fixed_image_mask
moving_image_masks: (a list of items which are an existing file name
         or &#39;NULL&#39;)
        Masks used to limit metric sampling region of the moving image,
        defined per registration stage(Use &quot;NULL&quot; to omit a mask at a given
        stage)
        mutually_exclusive: moving_image_mask
num_threads: (an integer (int or long), nipype default value: 1)
        Number of ITK threads to use
number_of_iterations: (a list of items which are a list of items
         which are an integer (int or long))
output_inverse_warped_image: (a boolean or a file name)
        requires: output_warped_image
output_transform_prefix: (a unicode string, nipype default value:
         transform)
        flag: %s
output_warped_image: (a boolean or a file name)
radius_bins_item_trait: (an integer (int or long), nipype default
         value: 5)
radius_bins_stage_trait: (an integer (int or long) or a list of items
         which are an integer (int or long))
radius_or_number_of_bins: (a list of items which are an integer (int
         or long) or a list of items which are an integer (int or long),
         nipype default value: [5])
        the number of bins in each stage for the MI and Mattes metric, the
        radius for other metrics
        requires: metric_weight
restore_state: (an existing file name)
        Filename for restoring the internal restorable state of the
        registration
        flag: --restore-state %s
restrict_deformation: (a list of items which are a list of items
         which are 0 or 1)
        This option allows the user to restrict the optimization of the
        displacement field, translation, rigid or affine transform on a per-
        component basis. For example, if one wants to limit the deformation
        or rotation of 3-D volume to the first two dimensions, this is
        possible by specifying a weight vector of &#39;1x1x0&#39; for a deformation
        field or &#39;1x1x0x1x1x0&#39; for a rigid transformation. Low-dimensional
        restriction only works if there are no preceding transformations.
sampling_percentage: (a list of items which are 0.0 &lt;= a floating
         point number &lt;= 1.0 or None or a list of items which are 0.0 &lt;= a
         floating point number &lt;= 1.0 or None)
        the metric sampling percentage(s) to use for each stage
        requires: sampling_strategy
sampling_percentage_item_trait: (0.0 &lt;= a floating point number &lt;=
         1.0 or None)
sampling_percentage_stage_trait: (0.0 &lt;= a floating point number &lt;=
         1.0 or None or a list of items which are 0.0 &lt;= a floating point
         number &lt;= 1.0 or None)
sampling_strategy: (a list of items which are &#39;None&#39; or &#39;Regular&#39; or
         &#39;Random&#39; or None or a list of items which are &#39;None&#39; or &#39;Regular&#39;
         or &#39;Random&#39; or None)
        the metric sampling strategy (strategies) for each stage
        requires: metric_weight
sampling_strategy_item_trait: (&#39;None&#39; or &#39;Regular&#39; or &#39;Random&#39; or
         None)
sampling_strategy_stage_trait: (&#39;None&#39; or &#39;Regular&#39; or &#39;Random&#39; or
         None or a list of items which are &#39;None&#39; or &#39;Regular&#39; or &#39;Random&#39;
         or None)
save_state: (a file name)
        Filename for saving the internal restorable state of the
        registration
        flag: --save-state %s
sigma_units: (a list of items which are &#39;mm&#39; or &#39;vox&#39;)
        units for smoothing sigmas
        requires: smoothing_sigmas
transform_parameters: (a list of items which are a tuple of the form:
         (a float) or a tuple of the form: (a float, a float, a float) or a
         tuple of the form: (a float, an integer (int or long), an integer
         (int or long), an integer (int or long)) or a tuple of the form: (a
         float, an integer (int or long), a float, a float, a float, a
         float) or a tuple of the form: (a float, a float, a float, an
         integer (int or long)) or a tuple of the form: (a float, an integer
         (int or long), an integer (int or long), an integer (int or long),
         an integer (int or long)))
use_estimate_learning_rate_once: (a list of items which are a
         boolean)
use_histogram_matching: (a boolean or a list of items which are a
         boolean, nipype default value: True)
        Histogram match the images before registration.
verbose: (a boolean, nipype default value: False)
        flag: -v
winsorize_lower_quantile: (0.0 &lt;= a floating point number &lt;= 1.0,
         nipype default value: 0.0)
        The Lower quantile to clip image ranges
        flag: %s
winsorize_upper_quantile: (0.0 &lt;= a floating point number &lt;= 1.0,
         nipype default value: 1.0)
        The Upper quantile to clip image ranges
        flag: %s
write_composite_transform: (a boolean, nipype default value: False)
        flag: --write-composite-transform %d
</pre></div>
</div>
<p>Outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">composite_transform</span><span class="p">:</span> <span class="p">(</span><span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Composite</span> <span class="n">transform</span> <span class="n">file</span>
<span class="n">elapsed_time</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">the</span> <span class="n">total</span> <span class="n">elapsed</span> <span class="n">time</span> <span class="k">as</span> <span class="n">reported</span> <span class="n">by</span> <span class="n">ANTs</span>
<span class="n">forward_invert_flags</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">items</span> <span class="n">which</span> <span class="n">are</span> <span class="n">a</span> <span class="n">boolean</span><span class="p">)</span>
        <span class="n">List</span> <span class="n">of</span> <span class="n">flags</span> <span class="n">corresponding</span> <span class="n">to</span> <span class="n">the</span> <span class="n">forward</span> <span class="n">transforms</span>
<span class="n">forward_transforms</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">items</span> <span class="n">which</span> <span class="n">are</span> <span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">List</span> <span class="n">of</span> <span class="n">output</span> <span class="n">transforms</span> <span class="k">for</span> <span class="n">forward</span> <span class="n">registration</span>
<span class="n">inverse_composite_transform</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Inverse</span> <span class="n">composite</span> <span class="n">transform</span> <span class="n">file</span>
<span class="n">inverse_warped_image</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Outputs</span> <span class="n">the</span> <span class="n">inverse</span> <span class="n">of</span> <span class="n">the</span> <span class="n">warped</span> <span class="n">image</span>
<span class="n">metric_value</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">the</span> <span class="n">final</span> <span class="n">value</span> <span class="n">of</span> <span class="n">metric</span>
<span class="n">reverse_invert_flags</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">items</span> <span class="n">which</span> <span class="n">are</span> <span class="n">a</span> <span class="n">boolean</span><span class="p">)</span>
        <span class="n">List</span> <span class="n">of</span> <span class="n">flags</span> <span class="n">corresponding</span> <span class="n">to</span> <span class="n">the</span> <span class="n">reverse</span> <span class="n">transforms</span>
<span class="n">reverse_transforms</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">items</span> <span class="n">which</span> <span class="n">are</span> <span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">List</span> <span class="n">of</span> <span class="n">output</span> <span class="n">transforms</span> <span class="k">for</span> <span class="n">reverse</span> <span class="n">registration</span>
<span class="n">save_state</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">The</span> <span class="n">saved</span> <span class="n">registration</span> <span class="n">state</span> <span class="n">to</span> <span class="n">be</span> <span class="n">restored</span>
<span class="n">warped_image</span><span class="p">:</span> <span class="p">(</span><span class="n">a</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Outputs</span> <span class="n">warped</span> <span class="n">image</span>
</pre></div>
</div>
<span class="target" id="nipype-interfaces-ants-registration-registrationsynquick"></span></div>
</div>
<div class="section" id="registrationsynquick">
<span id="index-2"></span><h2>RegistrationSynQuick<a class="headerlink" href="#registrationsynquick" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="http://github.com/nipy/nipype/tree/93c475b/nipype/interfaces/ants/registration.py#L1541">Link to code</a></p>
<p>Wraps command <strong>antsRegistrationSyNQuick.sh</strong></p>
<p>Registration using a symmetric image normalization method (SyN).
You can read more in Avants et al.; Med Image Anal., 2008
(<a class="reference external" href="https://www.ncbi.nlm.nih.gov/pubmed/17659998">https://www.ncbi.nlm.nih.gov/pubmed/17659998</a>).</p>
<div class="section" id="id2">
<h3>Examples<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.interfaces.ants</span> <span class="k">import</span> <span class="n">RegistrationSynQuick</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="n">RegistrationSynQuick</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image</span> <span class="o">=</span> <span class="s1">&#39;fixed1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image</span> <span class="o">=</span> <span class="s1">&#39;moving1.nii&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistrationSyNQuick.sh -d 3 -f fixed1.nii -r 32 -m moving1.nii -n 2 -o transform -p d -s 26 -t s&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># doctest: +SKIP</span>
</pre></div>
</div>
<p>example for multiple images</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">nipype.interfaces.ants</span> <span class="k">import</span> <span class="n">RegistrationSynQuick</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span> <span class="o">=</span> <span class="n">RegistrationSynQuick</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">fixed_image</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fixed1.nii&#39;</span><span class="p">,</span> <span class="s1">&#39;fixed2.nii&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">moving_image</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;moving1.nii&#39;</span><span class="p">,</span> <span class="s1">&#39;moving2.nii&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">num_threads</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">cmdline</span>
<span class="go">&#39;antsRegistrationSyNQuick.sh -d 3 -f fixed1.nii -f fixed2.nii -r 32 -m moving1.nii -m moving2.nii -n 2 -o transform -p d -s 26 -t s&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reg</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>  <span class="c1"># doctest: +SKIP</span>
</pre></div>
</div>
<p>Inputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>[Mandatory]
fixed_image: (a list of items which are an existing file name)
        Fixed image or source image or reference image
        flag: -f %s...
moving_image: (a list of items which are an existing file name)
        Moving image or target image
        flag: -m %s...

[Optional]
args: (a unicode string)
        Additional parameters to the command
        flag: %s
dimension: (3 or 2, nipype default value: 3)
        image dimension (2 or 3)
        flag: -d %d
environ: (a dictionary with keys which are a bytes or None or a value
         of class &#39;str&#39; and with values which are a bytes or None or a value
         of class &#39;str&#39;, nipype default value: {})
        Environment variables
histogram_bins: (an integer (int or long), nipype default value: 32)
        histogram bins for mutual information in SyN stage (default = 32)
        flag: -r %d
num_threads: (an integer (int or long), nipype default value: 1)
        Number of threads (default = 1)
        flag: -n %d
output_prefix: (a unicode string, nipype default value: transform)
        A prefix that is prepended to all output files
        flag: -o %s
precision_type: (&#39;double&#39; or &#39;float&#39;, nipype default value: double)
        precision type (default = double)
        flag: -p %s
spline_distance: (an integer (int or long), nipype default value: 26)
        spline distance for deformable B-spline SyN transform (default = 26)
        flag: -s %d
transform_type: (&#39;s&#39; or &#39;t&#39; or &#39;r&#39; or &#39;a&#39; or &#39;sr&#39; or &#39;b&#39; or &#39;br&#39;,
         nipype default value: s)
         transform type
         t: translation
         r: rigid
         a: rigid + affine
         s: rigid + affine + deformable syn (default)
         sr: rigid + deformable syn
         b: rigid + affine + deformable b-spline syn
         br: rigid + deformable b-spline syn
        flag: -t %s
use_histogram_matching: (a boolean)
        use histogram matching
        flag: -j %d
</pre></div>
</div>
<p>Outputs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">forward_warp_field</span><span class="p">:</span> <span class="p">(</span><span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Forward</span> <span class="n">warp</span> <span class="n">field</span>
<span class="n">inverse_warp_field</span><span class="p">:</span> <span class="p">(</span><span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Inverse</span> <span class="n">warp</span> <span class="n">field</span>
<span class="n">inverse_warped_image</span><span class="p">:</span> <span class="p">(</span><span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Inverse</span> <span class="n">warped</span> <span class="n">image</span>
<span class="n">out_matrix</span><span class="p">:</span> <span class="p">(</span><span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Affine</span> <span class="n">matrix</span>
<span class="n">warped_image</span><span class="p">:</span> <span class="p">(</span><span class="n">an</span> <span class="n">existing</span> <span class="n">file</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">Warped</span> <span class="n">image</span>
</pre></div>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-18, Neuroimaging in Python team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.1.
    </div>
<div class="footer">This page uses <a href="http://analytics.google.com/">
Google Analytics</a> to collect statistics. You can disable it by blocking
the JavaScript coming from www.google-analytics.com.
</div>

  </body>
</html>